package utils

import org.scalatest.{GivenWhenThen, Matchers, FunSpec}
import java.security.Security
import org.bouncycastle.jce.provider.BouncyCastleProvider
import play.api.test.{FakeHeaders, FakeRequest}
import twentysix.payplug.models.{PayplugPaymentStatus, PayplugPayment}
import play.api.libs.json.{JsObject, JsString, Json}
import org.joda.time.DateTime
import play.api.mvc.{Request, RawBuffer}
import twentysix.payplug.utils.CustomPayplugUtils

class PayplugUtilsTests extends FunSpec with Matchers with GivenWhenThen {

  val payplugUtilsStub = CustomPayplugUtils(
    "Payment Mock",
    "http://return-url/",
    "http://ipn-url/",
    "http://base-url/",
    getClass.getResource("/payplug-test.pem").getFile,
    getClass.getResource("/payplug-test.pub").getFile
  )

  def fakeRequest(params: JsObject, signature: Option[String]): Request[RawBuffer] = {
    val headers = signature.map {s => Seq("PayPlug-Signature" -> Seq(s))}.getOrElse(Seq())
    FakeRequest[RawBuffer]("POST",payplugUtilsStub.baseUrl,FakeHeaders(headers), RawBuffer(Int.MaxValue, params.toString().getBytes("UTF-8")))
  }

  describe("Payplug URL generation") {
    it("should generate a query string from a parameters map") {
      Given("a map of parameters (a->1, b->2)")
      val params = Map("a" -> "1", "b" -> "2")

      When("we convert it to a query string")
      val result = payplugUtilsStub.paramsMapToQueryString(params)

      Then("the result should be 'a=1&b=2'")
      result should be("a=1&b=2")
    }

    it("should generate a complete URL from a parameters map") {
      Security.addProvider(new BouncyCastleProvider())
      Given("a map of parameters (a->1, b->2)")
      val params = Map("a" -> "1", "b" -> "2")

      When("we generate an URL based on it")
      val result = payplugUtilsStub.getUrl(params)

      Then("the result should be as expected")
      //Generated by: printf "a=1&b=2" | openssl base64 | perl -MURI::Escape -ne 'chomp;print uri_escape($_),"\n"'
      val codedParams = "YT0xJmI9Mg%3D%3D"
      //Generated by: printf "a=1&b=2" | openssl dgst -binary -sign payplug/payplug-vmt-dev.pem -sha1 | openssl base64 | perl -MURI::Escape -ne 'chomp;print uri_escape($_),"\n"'
      val signature = "iWUFtSaNLBPb6hIbkeUYcMCKhDiNTetbSNFyFnngBBYhYB07srQQGg1H5W37SgVOWUKNO%2FAJIMNOyTVfiM4nXeLVT5wa%2BhjZNj9G81dg9gDiqgKtqAmulrnDmwAblp3dChLGxeeKfrgBt77RsRvDmS%2Bf8RpV6yEEHFCQJB%2Fskk9fxsxI7y8guZqn46jnGqb1EwAOjfE7GQpHLz8FsEsKpEDrPrUOFExWbVrTyAqHFFjq3gpULDiatr%2BQkpl2b7%2FokAdtxEiymvylwLp7SZsp9K8XZf2C%2F0jDoTCLBwyh4G4grq6oOPfPhh0WCAXwWYLQLXCitQGvQOIRdPEMXC4Apw%3D%3D"
      result should be(s"${payplugUtilsStub.baseUrl}?data=$codedParams&sign=$signature")
    }
  }

  describe("Payplug Signature generation") {
    it("should correctly sign a message with a private SHA1-RSA key"){
      Security.addProvider(new BouncyCastleProvider())

      Given("a private key and a message")
      val message = "Hello World"

      When("we sign it with our private key")
      val result = payplugUtilsStub.getSignature(message)

      Then("the result should be coded as expected")
      //Generated by: printf "Hello World" | openssl dgst -binary -sign payplug/payplug-vmt-dev.pem -sha1 | openssl base64
      result should be("l6cm7xp3HJWyxXJ/Vrq8fVtTk04Ymqg1jDSchyLahpxavt40w/A4jE7s/sxp2rnKW+efB+PRL78jlWHUu/P51pVDMqX5GuTB6bcTaav3IaVZFIudjVG7e2usB3Wuy8ORKCA9ggrL+blZhu9Uu4WnVCPjCgiHUg6nPW6n7IodNZHY1wxLWAPUtVCgRNQEdAKh7Y4gixuRSgdRVC6Iwe1kwmZpoexj7HmLKkedjGkEYG1pEWuakA86AWlAV+j1hGfokYD2p21bzdkmJx5T3B5aLc2RPLRV6kpih2BIgW3GO+tXv9rUmYMgiKiEkwwDJfGvLd0Egn1cbaAA4V0d7UMsXw==")
    }
  }

  val validPayment = PayplugPayment("26", Json.obj("a" -> "1"), 2600, PayplugPaymentStatus.Pending, id=Some("42"))
  val validParams = Json.obj(
    "id_transaction" -> "UnitTest-T1",
    "state" -> "paid",
    "customer" -> "26",
    "order" -> "42",
    "custom_data" -> "{\"a\": \"1\"}",
    "origin" -> "PayplugUtilsTests"
  )
  //Generated by:
  // printf "{\"id_transaction\":\"UnitTest-T1\",\"state\":\"paid\",\"customer\":\"26\",\"order\":\"42\",\"custom_data\":\"{\\\\\"a\\\\\": \\\\\"1\\\\\"}\",\"origin\":\"PayplugUtilsTests\"}" | openssl dgst -binary -sign payplug/payplug-vmt-dev.pem -sha1 | openssl base64
  val validSignature = "s9bwIL9rYHtSJOkWtjmC8+cd8Jc8uogxipkxZY/kA4tB76SyFIADcrUMqbbk6g81R7iscdS4ASq+3udI6qXfSoWA6EYVx170yB0hWCHrEu3zabBG/JeM25oWsRxW261Ds0zblwGwx79rJNLexy37GijCNBhg5l9nV7iRo7nHPHl+OBi9K6MChC6A0kPY3ayImnvXrvWkxrNVWvifg/YferbWA+8S7sKnWUoLJqKv5azzMhENcZ98rJP2reaQpPrUixGEmCv56NOPQR3zuOcufjb6jdRAjVL8rmghCBHHi12uPjPsOuICGhR9lhq26R2WRb6+SD6i2fkh0zRrJZ1Ayw=="

  describe("Payplug IPN handling") {
    it("should mark the payment as paid"){
      Security.addProvider(new BouncyCastleProvider())

      Given("a pending Payment and a correct IPN request")
      val payment = validPayment
      val params = validParams
      val signature = validSignature

      val request = fakeRequest(params, Some(signature))

      When("we call the IPN return method")
      val result = payplugUtilsStub.updatePaymentFromIpn(payment, request)

      Then("the returned payment should be marked as paid")
      result.status should be(PayplugPaymentStatus.Paid)
      (result.details \ "payment_date").asOpt[DateTime] should be(defined)
    }

    it("should mark the payment as reimbursed"){
      Security.addProvider(new BouncyCastleProvider())

      Given("a pending Payment and a correct IPN request")
      val payment = validPayment.copy(details = validPayment.details.as[JsObject] + ("payment_date" -> Json.toJson(DateTime.now())))
      val params = validParams - "state" + ("state" -> JsString("refunded"))
      //Generated by:
      // printf "{\"id_transaction\":\"UnitTest-T1\",\"customer\":\"26\",\"order\":\"42\",\"custom_data\":\"{\\\\\"a\\\\\": \\\\\"1\\\\\"}\",\"origin\":\"PayplugUtilsTests\",\"state\":\"refunded\"}" | openssl dgst -binary -sign payplug/payplug-vmt-dev.pem -sha1 | openssl base64
      val signature = "oqvbrkg+lX5caTrYnUE2LlN6VtVwRLSjvdJIsQnNHqyh5bJukuKWDOu7/SE2mpcOOTP65mXGQKGK36sq+3F9Gqz0MOW4eU1I+Bw1r89M5RkXQQbs7HwUUarLCzHcnJcHY2YX8oC3ewvkWCdSdWaSp63Rfjd19K2azZ3+ai/k/tQ94CW3sQUkP8vT9vHzRFA2o9WcxRpB81B3TK4sir2utDwCPOPxkRTqvl+hwkdm3l+TCb/raM09ZxEd+7qhlZwqQh//Ngt0G6MqM6fIrXx3pWDYo2pwdt/AwqhGpR+XyQvZ8CJmiX4fsmTknLyejVi+ShY/l7rodMOfmwWu3V/y5Q=="

      val request = fakeRequest(params, Some(signature))

      When("we call the IPN return method")
      val result = payplugUtilsStub.updatePaymentFromIpn(payment, request)

      Then("the returned payment should be marked as reimbursed")
      result.status should be(PayplugPaymentStatus.Reimbursed)
      (result.details \ "payment_date").asOpt[DateTime] should be(defined)
      (result.details \ "reimbursement_date").asOpt[DateTime] should be(defined)
    }

    it("should fail with a wrong signature"){
      Security.addProvider(new BouncyCastleProvider())

      Given("a pending Payment and a IPN request with a wrong signature")
      val payment = validPayment
      val params = validParams
      val signature = "H4><0r"

      val request = fakeRequest(params, Some(signature))

      When("we call the IPN return method")
      val exception = intercept[IllegalArgumentException] {
        payplugUtilsStub.updatePaymentFromIpn(payment, request)
      }

      Then("an exception should be thrown with the message: 'Incorrect IPN signature'")
      exception.getMessage should be("Incorrect IPN signature")
    }

    it("should fail with no signature"){
      Security.addProvider(new BouncyCastleProvider())

      Given("a pending Payment and a IPN request with a wrong signature")
      val payment = validPayment
      val params = validParams

      val request = fakeRequest(params, None)

      When("we call the IPN return method")
      val exception = intercept[IllegalArgumentException] {
        payplugUtilsStub.updatePaymentFromIpn(payment, request)
      }

      Then("an exception should be thrown with the message: 'IPN signature not found'")
      exception.getMessage should be("IPN signature not found")
    }

    it("should fail with a wrong customer"){
      Security.addProvider(new BouncyCastleProvider())

      Given("a pending Payment and a IPN request with a wrong customer id")
      val payment = validPayment.copy(userId = "666")
      val params = validParams
      val signature = validSignature

      val request = fakeRequest(params, Some(signature))

      When("we call the IPN return method")
      val exception = intercept[IllegalArgumentException] {
        payplugUtilsStub.updatePaymentFromIpn(payment, request)
      }

      Then("an exception should be thrown with the message: 'Parameter 'customer' (26) does not correspond to the payment userId (666).'")
      exception.getMessage should be("Parameter 'customer' (26) does not correspond to the payment userId (666).")
    }

    it("should fail with a wrong order id"){
      Security.addProvider(new BouncyCastleProvider())

      Given("a pending Payment and a IPN request with a wrong order id")
      val payment = validPayment.copy(id = Some("666"))
      val params = validParams
      val signature = validSignature

      val request = fakeRequest(params, Some(signature))

      When("we call the IPN return method")
      val exception = intercept[IllegalArgumentException] {
        payplugUtilsStub.updatePaymentFromIpn(payment, request)
      }

      Then("an exception should be thrown with the message: 'Parameter 'order' (42) does not correspond to the payment id (666).'")
      exception.getMessage should be("Parameter 'order' (42) does not correspond to the payment id (666).")
    }
  }

}
